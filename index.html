<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Learn JS</title>
  <style type="text/css">
    a {
      text-decoration: none;
      color: #000;
    }

    a:hover {
      color: lightgray;
    }

    .out {
      width: 85%;
      margin-left: 20px;
    }

    .main-title {
      text-align: center;
    }

    .code__exemple {
      background-color: lightgray;
    }

    .bold{
      font-weight: bold;
    }

  </style>
</head>
<body>
  <div class="out">
  <h1 class="main-title"><a href="http://learnjs.org.ua">Learnjs.org.ua</a></h1>
  <div class="about">
    <h2>Що таке Javascript</h2>
    <p>Мова іде про джаваскрипт у браузері, де його задача - маніпулювати ХТМЛ сторінкою.</p>
    <p>Так ось, єдиною мовою програмування, яку також можуть інтерпретовувати усі браузери, є Джаваскрипт.</p>
    <p>У джаваскрипті ми можемо писати "хендлери" - це певні набори дій, які відбуваються у разі, якщо юзер зробить певну дію. Наприклад, "якщо юзер клікнув по кнопці... сховати її".</p>
    <p>В той час, як ЦСС і ХТМЛ є <b>декларативними</b> мовами, в яких ми пишемо "ЩО МИ ХОТІЛИ Б БАЧИТИ"(div там або ul), то джаваскрипт(а також ініш популярні мови C, C++, Java, PHP) є <b>імперативною</b> мовою, в якій ми пишемо, "ЩО І ЯК РОБИТИ".</p>
  </div>
  <div id="variable">
    <h2>Змінні - Variables</h2>
    <p>Увесь Джаваскрипт, по суті, складається з двох речей: змінних і функцій. Змінні зберігають у собі дані, а функції їх обробляють, модифіковують і щось роблять.</p>
    <ul>
      <li>Кожна дія в джаваскрипт пишеться з нової стрічки</li>
      <li>Після кожної дії ми повинні ставити крапку з комою(але є винятки)</li>
      <li>Коли ми вперше використовуємо змінну, ми повинні писати ключове слово var(від англійського variable - змінна)</li>
      <li>Якщо ми хочемо записати у змінну слово або кілька слів - ми беремо їх у лапки. Числа у лапки можна не брати</li>
      <li>Назва змінної НЕ МОЖЕ починатись із ЦИФРИ</li>
      <li>Не вживайте ніяких спецсимволів у назві змінної! Тільки букви, цифри і нижнє підкреслювання!</li>
      <li>Ми можемо брати числа у лапки, якщо хочеться, а можемо і не брати! Краще НЕ брати</li>
      <li>Для того, щоб записати текст у кілька строчок, використовуйте об"єднання строчок за допомогою оператора "+"</li>  
    </ul>
    <p>Консоль необхідна програмісту для відлагоджування програми, в неї можна щось виводити, що не зачепить сам ХТМЛ документ, але допоможе нам зрозуміти, що відбувається у нас в коді.</p>
    <p>Слова у джаваскрипті прийнято називати строчками. Будь-який набір символів, окрім числа - це строчка. Строчки <b>обов"язково</b> беруться в лапки.</p>
    <p>Змінні бувають двох типів: строчки і числа, і змішувати їх не варто(або робити це обережно).</p>
    <p>З числами ми можемо робити арифметичні операції: ми можемо множити їх, ділити і віднімати!</p>
    <p>Змінні можна використовувати тільки після того, як ви їх оголосили.</p>
    <p>Окрім простого додавання, у джаваскрипті є також окрема операція, яка збільшує число на одиницю(називається інкремент).</p>
    <p>Окрім простого додавання, у джаваскрипті є також окрема операція, яка збільшує число на одиницю(називається інкремент). ++a;</p>
  </div>

  <div id="functions">
    <h2>Функції - Functions</h2>
    <p>Це сама сіль джаваскрипта. Якщо змінні потрібні для того, щоб зберігати дані, то функції покликані щось із ними робити. Вони бувають двох типів: стандартні, які входять у базовий джентльменський набір можливостей джаваскрипта, і самописні, які ви створюєте самі для вирішення своїх потреб.</p>
    <h3>Стандартні функції</h3>
    <p>Стандартні функції джаваскрипта дозволяють нам зробити ті речі, які ми самі нізащо не змогли б зробити, використовуючи лише змінні і відомі нам операції над ними. Наприклад, вивести юзеру в браузер повідомлення про щось.</p>
    <p>Тут alert(...) - це виклик функції. Кожна функція може викликатись будь-яку кількість разів, в будь-якому місці. Те, що знаходиться в дужках - це аргументи функції. Функція alert() виводить якесь повідомлення на екран. Але ж ми повинні вказати, яке! Ось для цього існують аргументи функції. Аргументи - це якісь дані, частіше за все змінні, які ми передаємо в функцію при її виклику. Як бачите, кожна функція має ім"я, по якому її можна викликати. Для того, щоб викликати функцію, треба написати її ім"я, відкрити дужки, написати там її аргументи, і закрити дужки :)</p>
    <h3>Методи</h3>
    <p class="code__exemple">var a = 'Hello, my name is John!';<br>
    var b = a.replace("John", 'Petro'); // 'Hello, my name is Petro!'</p>
    <p>Такі фунції викликаються якби "від змінної". Ви пишете ім"я змінної, ставите крапку, і далі пишете ту функцію, яку хотіли б до неї застосувати!</p>
    <p class="code__exemple">var a = 'I am A CaMeL';<br>
    a = a.toLowerCase();// 'i am a camel'</p>
    <p>Давайте тепер роздивимось, що це за функції і як з ними поводитись. Вище були згадані дві функції, replace() і toLowerCase(). Перша функція, як ви здогадались, замінює в строчці задані слова іншими. Друга функція робить усі букви у строчці - прописними, тобто, у нижньому регістрі.</p>
    <p>Ці функції відносяться до групи т.зв. строкових функцій, тобто функцій, які призначені для роботи зі строчками. Вони викликаються "від змінної", тобто, через крапку після імені змінної. Функція replace() має два аргументи - перший означає "шо шукати", а другий - "на що замінити знайдені строчки".</p>
    <p>Функція toLowerCase() не має аргументів взагалі. Ви можете спитати, а як вона дізнається, з якою строчкою їй працювати? Справа в тому, що передавати вихідну строчку немає потреби, так як нею є та строчка, "від якої" ми викликаємо функцію. В даному випадку, змінна "а". У цьому і весь сенс виклику "від змінної": він якби по замовчуванню використовує ту змінну, від якої ми виликаємо. Такі функції у джаваскрипті називаються "методами"(це важливий термін, запам"ятайте його).</p>
    <p class="code__exemple">var str = 'Donatas Banionis';<br>
    str = str.replace("s", "");<br>
    console.log(str);// 'Donata Banionis'</p>
    <p>Ми замінили літеру "s" на пусту строчку, тобто, фактично - вирізали її. Зверніть увагу, метод replace() замінює лише перше входження шуканої строчки! Виклик методу не впливає на ту змінну, від якої ми його викликали. Для того, щоб змінити значення змінної, його треба в неї записати.</p>
    <p class="code__exemple">var fruits = 'bananas, apples, carrots';<br><br>
    // carrots?!<br>
    var real_fruits = fruits.replace("carrot", "apricot");<br><br>
    console.log(real_fruits); // 'bananas, apples, apricots'<br>
    console.log(fruits); // 'bananas, apples, carrots' - без змін, як і очікувалось!</p>
    <p>Джаваскрипт має багато стандартних функцій і методів для роботи зі строчками і числами, повний перелік ви можете знайти в інтернеті) Ми будемо поступово знайомитися із деякими з них.</p>
    <h3>Самописні функції</h3>
    <p>Нарешті, ви можете створювати функції самі! Це відбувається у два етапи:<br>
    а) ви описуєте функцію<br>
    б) користуєтесь нею!</p>
    <p>При чому, другий етап вам вже відомий - самописними функціями користуються так само, як і стандартними. А от як описати функцію? Для цього є певний синтаксис. Коли ви зустрічаєте слово "синтаксис" в цьому підручнику, це означає, що зараз буде приклад, в якому треба звертати увагу на найменші дрібниці і нюанси, і свято дотримуватись їх, інакше ваш код не запрацює. Вам вже відомий синтаксис оголошення змінних(слово var), синтаксис операцій(знак дорівнює і крапка з комою в кінці), і ви вже знаєте, як викликати функції(написати ім"я функції і в дужках аргументи).</p>
    <p>Тепер ви повинні запам"ятати синтаксис оголошення функції.</p>
    <p>Тут уже є багато над чим помедитувати. Для початку, розберемось із синтаксисом, тобто, як треба правильно розставляти фігурні дужки і коми, щоб у вас усе працювало.</p>
    <p>По-перше, зверніть увагу, що оголошення функції подібне до створення змінної - ліва частина у них однакова. Ми пишемо ключове слово "var" і назву функції, яку ми хотіли б їй дати. А ось права частина специфічна. Ми пишемо ключове слово function, потім відкриваємо дужки, перераховуємо список аргументів, закриваємо дужки, відкриваємо фігурні дужки, пишемо тіло функції, і закриваємо дужки. Ми можемо не написати жодного аргументу, тіло може бути пустим, але ключове слово function, дужки і фігурні дужки ви зобов"язані написати!</p>
    <p class="code__exemple">var stupid = function(){}; // це цілком правильний запис!<br>
    Щоправда, толку від такої функції небагато</p>
    <h3>Як працюють функції. Оголошення і передача аргументів</h3>
    <p>Але як це працює? Чому ми у функції wrap_in_tag назвали аргументи str i tagname, а передали туди змінні g i a, як це працює? Ось ще один приклад для медитації.</p>
    <p class="code__exemple">var he = 'John';<br>
    var she = 'Mary';<br>
    var merry = function(bride, groom){<br>
    return 'Congratulations, ' + groom + ' and ' + bride + ', you are married!';<br>
    }<br>
    var happy_message = merry(she, he);</p>
    <p>Будь-який процес має абстрактний формальний опис(як це взагалі робиться), і має конкретні випадки реального свого застосування. Так ось, це саме те, що ми робимо із функціями! </p>
    <p>Ми описали абстрактну функцію "одружитися", яка приймає два аргументи(наречену і нареченого), і щось робить(в даному випадку, просто формує привітання для них). Поки що ніхто ні з ким не одружується насправді, ми лише описуємо процес одруження, як воно має відбуватись. У програмуванні це називається - <span class="bold">ми оголосили функцію</span>. А вже після оголошення, ми можемо її застосовувати! Тобто, женити конкретних іванів і марійок!</p>
    <p>Це - застосування функції, або, як кажуть у програмуванні - <span class="bold">виклик</span>. Функція merry була викликана, при цьому їй були передані змінні she(в якості аргумента bride) і he(в якості аргумента groom). Результат роботи функції(строчка) був записаний у змінну happy_message.</p>
    <p>Тут є ще один момент, який необхідно пояснити. У програмуванні функції потрібні, перш за все, для того, щоб проводити обчислення. Тобто, пілся виконання, функція повинна повернути якийсь результат. Але що буде слугувати результатом функції? Для цього нам потрібне ключове слово <span class="bold">return</span>. Коли ми пишемо <span class="bold">return</span>, це означає: повернути те, що стоїть після <span class="bold">return</span>, в якості результата роботи функції, і припинити її подальше виконання.</p>
    <p>Зверніть увагу! Функції мають спільний простір імен із змінними!</p>
    <p>Після слова <span class="bold">return</span> функція припиняє роботу і повертає результат.</p>
    <p>Напишіть функцію round_area(), яка рахує площу кола по переданому їй діаметру(вважаючи, що число Пі дорівнює 3.14).</p>
    <p>Завдання на додатковий бал: напишіть функцію wrap_in_tag(str, tag), яка повертає строчку, загорнуту в тег, а також функцію wrap_in_div, яка, використовуючи першу функцію, загортає строчку в тег div.</p>
    <h3>Область видимості змінних</h3>
    <p>Що таке область видимості змінних? Про що йде мова? Ну, ви вже знаєте, що, наприклад, не можна використовувати змінну раніше, ніж вона оголошена.</p>
    <p>Тобто, ви вже розумієте, що змінні не можна використовувати де завгодно. А як бути зі змінними, оголошеними в функції?</p>
    <p>Змінні, оголошені всередині функцій, існують самі по собі, і ніяк не перетинаються із зовнішніми змінними! А чи можна із функції звернутись до зовнішньої змінної? Так!</p>
    <p>Отже, із змінними у функціях запам"ятатйте цей принцип: "я тебе бачу, ти мене ні": всередині функцій ми можемо звертатись і до зовнішніх змінних, і до внутрішніх, а ззовні добратися до змінних із функцій ми не можемо!</p>
    <p></p>
  </div>

  <div id="">
    <h2>Гілкування</h2>
    <p>Джаваскрипт і подібні мови називають також мовами сценаріїв, і це досить влучна назва. Програма, написана на Джаваскрипті, описує, як будуть розгортатися події на підмостках браузера, що буде показано юзеру що буде робитись із ХТМЛ сторінкою. Цю паралель можна розвивати і далі, але є дуже суттєва відмінність між програмуванням і театральним сценарієм. На відміну від театру, де Отелло буде убивати Дездемону кожного разу, скільки буде ставитись п"єса, програмам властива деяка гнучкість, інтерактивність.</p>
    <p>Досі все, що ми писали, було простою послідовністю дій: візьми те, запиши туди те, запусти функцію таку. Тобто, наша програма кожного разу працювала б по одній і тій же схемі. Однак це не цікаво! На допомогу нам приходить механізм розгалуження, гілкування. Гілкування працює так: ми перевіряємо якусь умову, якщо вона вірна - робимо одне, якщо не вірна - робимо інше. "Якщо це так, то зроби це. Якщо це НЕ так, то зроби щось інше"</p>
    <p>Припустимо, нам треба написати функцію, яка поверне із двох чисел те, котре найбільше. Ось її реалізація.</p>
    <p class="code__exemple">var Desdemona_is_guilty = false;<br>

if(Desdemona_is_guilty){ // <- початок гілкування. Ключове слово if, умова Desdemona_is_guilty<br>
  kill('Desdemona');<br>
} else {<br>
  kill('Iago');<br>
}</p>
    <p>Поки що не заглиблюємось у нюанси, загальна суть того, що відбувається, приблизно зрозуміла. Припустимо, нам треба написати функцію, яка поверне із двох чисел те, котре найбільше. Ось її реалізація.</p>
    <p><pre class="code__exemple">
var get_max = function(a, b){
  if(a > b) {
    return a;
  } else {
    return b;
  }
}

get_max(20, 13); // 20
get_max(1, 2); // 2
    </pre></p>
    <p>Давайте тепер розберемось в синтаксисі. Перше, що ви повинні побачити і запам"ятати - це ключове слово if. З нього починається розгалуження. В дужках після if ми пишемо те, що ми хочемо перевірити. Наприклад, чи одне число більше за інше. Після цього ми відкриваємо фігурні дужки, і пишемо те, що виконається, якщо написана нами умова вірна. Потім ми закриваємо їх, і можемо написати ще одне ключове слово, else, і після нього той код, який виконається, якщо умова НЕ вірна.</p>
    <p>Зверніть увагу, що та умова, яку ми пишемо, завжди має лише два варіанти: так або ні, істина або брехня. Наприклад, " if(вона вагітна) { ...робимо щось одне... } else { ...робимо щось інше... } Проміжних варіантів не може бути, або вагітна, або ні.</p>
    <p>У фігурних дужках ми можемо писати будь-який код: оголошувати змінні, викликати функції, все що завгодно, у т.ч. ще одне гілкування. Це логічно, адже сам набір дій у тому чи іншому разі може бути яким завгодно. Важливе питання - як ми можемо формулювати умови.</p>
    <h3>Перевірка умов</h3>
    <p>Крім перевірки на наявність/відсутність чого, можуть бути чисто математичні порівняння, які можна робити ЛИШЕ з числами: більше, менше, більше або дорівнює, менше або дорівнює. Ось так:</p>
    <p><pre class="code__exemple">
if(a > b){ ... } else { ... }
if(a < b){ ... } else { ... }
if(a <= b){ ... } else { ... } // менше або дорівнює
if(a >= b){ ... } else { ... } // більше або дорівнює
if(a == b) { ... } else { ... } // а дорівнює b
if(a != b) { ... } else { ... } // а НЕ дорівнює b      
    </pre></p>
    <p>Існує також помилка, настільки розповсюджена, що її хочеться розібрати окремо. Це ситуація, коли замість перевірки на рівність, яка здійснюється оператором "==", змінну присвоюють оператором "=". Між ними величезна різниця!</p>
    <p>// Увага, помилка! Замість перевірки на рівність ми ПРИСВОЇМО значення b в а<br>
    if(a = b) { ... цей код буде виконуватись майже завжди, бо ми просто запишемо b в а ...} else { ... }</p>
    <p>// Правильний варіант порівняння двох змінних<br>
    if(a == b) { ... } else { ... }</p>
    <p>Давайте розберемось, як правильно використовувати гілкування. Припустимо, нам треба написати функцію, яка пише вітання для юзера в залежності від його статі. У функцію буде передаватись ім"я юзера, а також стать, а повертати ми будемо строчку із привітанням. Ця функція, на відміну від попередніх, буде трішки дискримінуючою, тобто, вона буде себе вести по-різному, маючи справу з чоловіками і жінками.</p>
    <p><pre class="code__exemple">
  var get_sexist_greeting(name, gender){
  if(gender == 'male'){
    var greet = 'Hello, mr.' + name + '!';
    return greet;
  } else { // females, transgenders and other non-males
    var greet = 'Hello, ms.' + name + '!';
    return greet;
  }
}
    </pre></p>
    <p>Така функція, в принципі, буде працювати, однак, її можна трішки "покращити"(в хорошому розумінні цього слова). Гарний програміст старається не писати зайвого коду. Якщо ми подивимось на цю функцію, можна помітити, що результат відрізняється лише на одну букву. Більшу частину строчки можна зробити спільною, і варіювати лише невелику частинку, яка є звертанням.</p>
    <p><pre class="code__exemple">
var get_sexist_greeting(name, gender){
  if(gender == 'male'){
    var address = 'mr.';
  } else { // females, transgenders and other non-males
    var address = 'ms.';
  }
  var greet = 'Hello, ' + address + ' ' + name + '!';
  return greet;
}
    </pre></p>
    <p>Ось так вже значно краще! Ми ввели додаткову змінну, яка позначає частинку звертання і варіюється в залежності від статі, а інша частина строчки залишається спільною для всіх. Так ми трохи скоротили функцію і зробили її яснішою, читабельнішою. Вітаю, тепер ви знаєте що таке <span class="bold">рефакторинг</span>. Цей термін у програмуванні позначає <span class="bold">процес покращення якості коду без зміни результатів його діяльності</span>.</p>
    <h3>Логічний тип даних</h3>
    <p>Дотепер ми знали два типи даних: число і строчка. Зараз ви познайомитесь зі ще одним типом даних - логічним. Кожен тип даних характеризується можливим діапазоном значень. Давайте згадаємо, які у нас бувають строчки і числа.</p>
    <p><pre class="code__exemple">
var she_is_pregnant = false;
// ... щось відбулося ...
she_is_pregnant = true;
    </pre></p>
    <p>Усього два значення - true i false! Чорне і біле, правда і брехня. Дуже просто запам"ятати. Пишуться вони як строчки, тільки без лапок.</p>
    <p>Для чого потрібні такі змінні? Для використання у перевірці умов! Згадайте, що ми пишемо в дужках після if:</p>
    <p>Якщо ми пишемо 2 + 3, яке значення має цей вираз? Правильно, 5. А якщо ми пишемо 5 < 2, то яке значення буде у цього виразу? Звісно, false! Кожен раз, коли ми пишемо щось у дужках після if, цей вираз обчислюється, і ми дивимось, істинний він чи ні. Подивимось ще раз на приклад з початку розділу, тепер він буде вам зрозумілий.</p>
    <p><pre class="code__exemple">
var Desdemona_is_guilty = false;

if(Desdemona_is_guilty){
  kill('Desdemona');
} else {
  kill('Iago');
}
    </pre></p>
    <p>Ось тут, на щастя, буде убитий Яго, а не невинна Дездемона! Ми присвоїли у змінну Desdemona_is_guilty значення false, отже, буде виконана друга частина гілкування, та, котра йде після else!</p>
    <p>В if можна передавати не тільки змінні, а і складні конструкції, наприклад, виклики функцій. Припустимо, хлопчик хоче придбати цигарок. Ми будемо перевіряти за допомогою спеціальної функції, чи можна йому продати цигарки.</p>
    <p><pre class="code__exemple">

var we_can_sell_cigars = function(age){
  var permit = age >= 18; // у змінну permit попаде логічне значення, true або false!
  return permit;
}

var boy_age = 17;

if(we_can_sell_cigars(boy_age)){
  console.log('Fuck yeah!');
} else {
  console.log('Ok :(');
}
    </pre></p>
    <p>Ще раз подумаємо, що тут відбувається. Ми перевіряємо, чи можна продати хлопцю цигарки. У нас є конструкція if, значить, перш за все, ми обчислюємо значення в дужках. У дужках у нас викликається функція we_can_sell_cigars, при чому їй передається вік хлопчика(17 років).</p>
    <p>Всередині цієї функції ми приймаємо вік як аргумент age, і записуємо в змінну permit, чи не менший цей вік за 18. В даному випадку, таки менший, отже, змінна permit буде дорівнювати false. Ми повертаємо цю змінну як результат виконання функції we_can_sell_cigars в наш if, він бачить, що діла неважні(йому прийшло false), і розчаровує хлопчика, направляючи його шляхом else.</p>
    <h3>Кілька умов за раз</h3>
    <p>Нам треба написати функцію, яка б допомогла хлопцю розібратися, що з ним зараз відбувається. З одного боку, ми будемо перевіряти, чи не вагітна його дівчина, а з іншого, чи кохає він її. Результат(його поточний стан) буде таким: а) якщо вагітна і він кохає її - 'happy' б) якщо вагітна і НЕ кохає - 'in trouble' в) якщо НЕ вагітна і кохає - теж 'happy' г) якщо НЕ вагітна і НЕ кохає - 'OK'</p>
    <p>Отже, як нам написати таку функцію? В принципі, це не так складно, якщо розуміти, що гілкування може бути скільки завгодно вкладеним.</p>
    <p><pre class="code__exemple">

  var check_state = function(pregnant, in_love){
  if(pregnant){
    if(in_love){
      var state = 'happy';
    } else {
      var state = 'in_trouble';
    }
  } else {
    if(in_love){
      var state = 'happy';
    } else {
      var state = 'OK';
    }
  }
  return state;
}  
    </pre></p>
    <p>В принципі, працездатно, але ж так громіздко! Глибокі рівні вкладеності погіршують читабельність.</p>
    <p><pre class="code__exemple">
      
var check_state = function(pregnant, in_love){
  if(pregnant && in_love){
    var state = 'happy';
  }
  if(pregnant && !in_love){
    var state = 'in_trouble';
  }
  if(!pregnant && in_love){
    var state = 'happy';
  }
  if(!pregnant && !in_love){
    var state = 'OK';
  }
  return state; 
}
    </pre></p>
    <p>Отак вже краще! Отже, коли ми пишемо умову, ми можемо вживати ключове слово &&(називається "логічне І", читається як "and"). В результаті, значення всього виразу "pregnant && in_love" буде true, тільки якщо і pregnant, i in_love будуть true. Якщо ж хоч одне щось із них буде false - весь вираз буде рівним false!</p>
    <p>І ще цікава річ, яку ви, сподіваюсь помітили - знако оклику перед змінною. Він означає заперечення. Тобто, !love означає НЕ love.</p>
    <p>Крім логічного AND(&&), є ще і логічне OR, яке записується як ||(дві палки). Воно допоможе нам покращити код. Ми бачимо, що два випадки є аналогічними(дають один і той же результат - happy). Отже, ми можемо об"єднати їх в один.</p>
    <p><pre class="code__exemple">
      
var check_state = function(pregnant, in_love){
  if((pregnant && in_love) || (!pregnant && in_love)){
    var state = 'happy';
  }
  if(pregnant && !in_love){
    var state = 'in_trouble';
  }
  if(!pregnant && !in_love){
    var state = 'OK';
  }
  return state; 
}
    </pre></p>
    <p>Уже одним кейсом менше! Як ви можете побачити, складова else не є обов"язковою! Логічне OR дає true, якщо хоча б один із його складових є true. Але ми можемо ще спростити нашу функцію! Якщо придивитись, у першій умові не важливо, pregnant чи не pregnant, головне щоб in_love було true.</p>
    <p><pre class="code__exemple">
      
var check_state = function(pregnant, in_love){
  if(in_love){
    var state = 'happy';
  } else {
    if(pregnant){
      var state = 'in_trouble';
    } else {
      var state = 'OK';
    }
  }
  return state; 
}
    </pre></p>
    <p>Мене, чесно кажучи, напрягає писати по багату разів var, а якщо ще відвертіше казати, то це і взагалі неправильно. Тому спробуємо оголосити змінну один раз на початку, присвоївши їй якесь значення по замовчуванню</p>
    <p><pre class="code__exemple">
      
var check_state = function(pregnant, in_love){
  var state = 'happy';
  if(!in_love){
    if(pregnant){
      state = 'in_trouble';
    } else {
      state = 'OK';
    }
  }
  return state; 
}
    </pre></p>
    <p>Ось це вже мені подобається! var пишемо один раз. Тобто, змінна гарантовано оголошується на початку, а далі, в певних ситуаціях, може бути перезаписана. Вітаю, ви ще раз попрактикувались у рефакторингу, і розібрались, як вправлятись із логічними запереченням(!), AND(&&) i OR(||).</p>
    
  </div>
  <div>
    <h2>Об"єкти</h2>
    <p>Для чого потрібні об"єкти, можна легко зрозуміти, згадавши один із попередніх прикладів.</p>
    <p><pre class="code__exemple">
var he = 'John';
var she = 'Mary';
var merry = function(bride, groom){
  return 'Congratulations, ' + groom + ' and ' + bride + ', you are married!';
}
var happy_message = merry(she, he);
    </pre></p>
    <p>Ця функція працює непогано, але вона занадто проста. Зазвичай в житті все буває складніше, наприклад, працівники ЗАГСу, йомвірно, перевірять, чи є молодята різної статі, або чи не є один із них уже одруженим на даний момент. Отже, як ми можемо в нашій функції запобігти багатоженству? Що ж, ми можемо ввести додаткові логічні змінні, які будуть зберігати інформацію про поточний статус.</p>
    <p><pre class="code__exemple">
var person_1_name = 'Petro';
var person_1_status = 'unmarried';
var person_2_name = 'Mary';
var person_2_status = 'divorced';

var merry = function(name1, status1, name2, status2){
    if(status1 == 'married' OR status2 == 'married'){
        return 'Marriage failed, error code 400';
    }
  return 'Congratulations, ' + name1 + ' and ' + name2 + ', you are married!';
}
    </pre></p>
    <p>Вам вже страшно? Мені, особисто, так. 6 аргументів - це вже занадто! На кожну людину нам треба завести по 3 змінні, що означають якісь її характеристики: ім"я, стать, шлюбний статус. Але ж є ще прізвище, адреса, вік... Так ми заморимось створювати змінні :)</p>
    <p>Ідея об"єктів полягає у тому, щоб згрупувати разом змінні, які позначають властивості одного і того самого предмета. У вас бувала ситуація, коли весь робочий стіл завалений ярликами і файлами? Як ви з цим боролися? В ідеалі, треба створити тематичні папки, і розкладати файли по ним. Так само ми вчинимо і з нашими змінними. Об"єкти - це "папки", у які ми будемо складати змінні("файли").</p>
    <p><pre class="code__exemple">

var person_1 = {
    name: 'Petro',
    status: 'unmarried',
    gender: 'male'
}

var person_2 = {
    name: 'Mary',
    status: 'divorced',
    gender: 'female'
}
var merry = function(person1, person2){
    if(person1.status == 'married' OR person2.status == 'married'){
        return 'Marriage failed, error code 400';
    }
    if(person1.gender == person2.gender){
        return 'Homosexual marriages prohibited!';
    }
    // !!! дуже важливий момент! Якщо все ок, і пару ми можемо поженити, ми повинні змінити їх статус!
    person1.status = 'married';
    person2.status = 'married';
  return 'Congratulations, ' + name1 + ' and ' + name2 + ', you are married!';
}
    </pre></p>
    <p>Оце вже інша справа! Давайте розбиратись.</p>
    <p><pre class="code__exemple">
      
var person_1 = {
    name: 'Petro',
    status: 'unmarried',
    gender: 'male'
}
    </pre></p>
    <p>Ось це - справжнісінький об"єкт! Це як наче папка, в якій лежать файли "1.txt", "КУРСОВА!!!!!.doc", "wfnrw7yg9834tn34kt.jpg" і інші. В якості "файлів" у нас - змінні. Ліва частина об"єкту оголошується так само, як і змінна - var %somename%. Права частина загорнута у фігурні дужки, і містить перелік змінних, які вкладені в об"єкт. Зліва пишуться імена змінних(ключі), а справа - значення. Змінні об"єкта називаються властивостями або полями об"єкта.</p>
    <p>В об"єкт можна покласти будь-яку змінну, наприклад, логічну або число. Або навіть інший об"єкт!(адже ми можемо покласти папку в папку)</p>
    <p><pre class="code__exemple">
      
var men = {
    name: 'Ivan',
    age: 25,
    gender: 'M',
    wife: {
        name: 'Ann',
        age: 23,
        gender: female,
    }
}
    </pre></p>
    <p>Пари "ключ/значення" розділені комами(останню кому бажано не ставити).</p>
    <p>А тепер подивимось, як поводитись із об"єктами. Як добратись до його властивостей? - дуже просто, через крапку!</p>
    <p><pre class="code__exemple">

men.name; // "Ivan"
men.age; // 25
men.wife.gender; // "female"
    </pre></p>
    <p>Як бачите, рівень вкладеності може бути яким завгодно глибоким! Можливо, нотація через крапку вам буде незвичною спочатку, т.як асоціюється із закінченням речення або скороченням. Згадайте компанію Яндекс, яка усі свої сервіси називає через крапку: "Яндекс.Директ", "Яндекс.Розклади" і т.д. Вочевидь, таке йменування виникло по мотивам об"єктної нотації.</p>
    <h3>Пусте значення(undefined)</h3>
    <p>Що буде, якщо ми звернемось до змінної, якої нема?(яку ми не оголошували) Виникне помилка!</p>
    <p><pre class="code__exemple">
      
      alert(some_stupid_name); // помилка!
    </pre></p>
    <p>А от якщо спробувати пошукати властивість об"єкта, якої нема, нам це пробачать. Просто ми отримаємо пусте значення, яке називається undefined.</p>
    <p><pre class="code__exemple">
      
var a = {
  ene: 'bene',
  kvinter: 'finter',
}
console.log(a.zhaba); // undefined
    </pre></p>
    <p>Undefined - це таке спеціальне значення, єдине у своєму роді. Воно трохи схоже на false, тим, що якщо ви будете перевіряти його, воно буде давати негативний результат.</p>
    <p><pre class="code__exemple">
      
if(a.zhaba){
  // цей код ніколи не виконається
} else {
  // а оцей - так
}
    </pre></p>
    <p>Однак його не слід плутати із false. Заперечення і відсутність будь-чого - це зовсім різні речі. Наприклад, вам задають питання, "Чи плямкаєте ви, коли гризете батарею?". Питання поставлене так, що очікується відповідь у формі "так" або "ні", true або false. Але, скоріше за все, ви не скажете ні "так", ні "ні", а спробуєте довести своєму співрозмовнику, що ви не гризете батареї. Ось це і буде undefined.</p>
    <p><pre class="code__exemple">
      
var person = {
  name: 'Zigmund',
  smokes: false
}
if(person.smokes == undefined){
  ...
  // дії, якщо це поле відсутнє
}
if(!person.smokes){
  // дії, якщо людина не курить
}
    </pre></p>
    <h3>Що можна робити з об"єктами</h3>
    <p>Об"єкти, як ви, можливо, здогадались, є ще одним типом даних(нарівні із числами, строчками і логічними значеннями). Одна з ними не можна робити майже нічого з того, що ми звикли робити з іншими типами даних. Їх не можна додавати(віднімати, ділити і т.п.), складати у строчку.</p>
    <p>Знову ж таки, звернемось до аналогії з папками. Ви не можете редагувати папку(що ви будете в ній редагувати?!). Ви можете редагувати файл у папці, можете прибрати файл із папки, додати файл у неї, але сама папка ніяких власнивостей не має, окрім імені. Давайте подивимось, як виглядають ці операції з об"єктами:</p>
    <p><pre class="code__exemple">
      
var car = {};// створюємо пустий об"єкт

car.power = 1000; // додаємо нову властивість(змінну) в об"єкт, ключ "power", значення 1000.
car.color = 'red';
сar.brand = 'Ferrari';
// тепер подивимось, що вийшло
console.log(car); // Object {power: 1000, color: "red", brand: "Ferrari"} 
// як бачите, коли ми виводимо об"єкт в консоль, він показується нам з усіма властивостями

// Перевіримо, чи є у об"єкта властивість
if(car.color){ ... }

//Однак, ця перевірка не спрацює, якщо в полі color буде значення 0 або false.
//Для того, щоб відрізнити відсутність поля від поля зі значенням false, пишемо так
if(car.color != undefined){ ... }

// спробуємо видалити властивість
delete car.color; // насправді, вам майже не знадобиться ця операція

// редагування змінних об"єкта не відрізняється від початкового присвоєння
car.color = 'yellow'; // тепер колір змінився

// подивимось окрему властивість
console.log(car.color); // 'yellow'
    </pre></p>
    <p>Також ми можемо отримати ключ, ім"я якого лежить у змінній! Для цього існує спеціальна нотація.</p>
    <p><pre class="code__exemple">
      
var man = {
  name: 'Jimmi',
  surname: 'Hendrix',
  job: 'genius',
  age: 28
}

var key = 'name';

console.log(man.name); // Jimmi
//!!! Увага !!!
console.log(man[key]); // Jimmi!

key = 'age';
man[key]++;
console.log(man.age); // 29
console.log(man['age']); // 29
    </pre></p>
    <p>Як бачите, є два способи звернутись до ключа об"єкта: через крапку, написавши її безпосереднє значення, або через квадратні дужки, передавши строчку, яка означає ім"я ключа! Можна передавати безпосередньо строчку або змінну, яка містить строчку.</p>
    <p>// Напишіть функцію create_user, яка приймає ім"я юзера і його прізвище,<br>
    // і повертає об"єкт із полями name і surname</p>
    <p><pre class="code__exemple">
      
    var create_user = function(n, s){
        var user = {
            name: n,
            surname: s
        }
        return user;
    }

    </pre></p>
    <p>Напишіть функцію celebrateBirthday, яка приймає об"єкт, і дивиться, чи є у нього поле age. Якщо таке поле є, вона збільшує його значення на одиницю. Якщо такого поля нема, то нічого не робить. В будь-якому разі, функція повертає об"єкт, який прийняла.</p>
    <p><pre class="code__exemple">
      
    var celebrateBirthday = function(user){
        if(user.age !== undefined){
            user.age++;
        }
        return user;
    }
    </pre></p>
    <p>Напишіть функцію getKey, яка приймає об"єкт і ім"я ключа, і повертає його значення</p>
    <p><pre class="code__exemple">
      
    var getKey = function(obj, key){
        return obj[key];
    }
    </pre></p>
    <h3>Методи</h3>
    <p>А що буде, якщо запхнути в об"єкт функцію? Це розпосюджений прийом. Функції, як і змінні, корисно групувати. Тепер, коли ви вже знаєте, що таке об"єкти, ви можете свіжим оком подивитись на нашу стару знайому консоль(console.log), і зрозуміти, що console - це об"єкт, а log - це його метод(функція, яка записана в поле об"єкта). Крім цього, існують і інші методи, наприклад, console.dir().</p>
    <p>В принципі, на перший погляд, робота метода нічим не відрізняється від звичайної функції.</p>
    <p><pre class="code__exemple">
      
var user = {
    name: 'Konrad',
    surname: 'Mikhelson',
    get_fullname: function(name, surname){
        return 'I am ' + name + ' Karlovych ' + surname;
    }
}
    </pre></p>
    <p><pre class="code__exemple">
var full_name = user.get_fullname(user.name, user.surname); // I am Konrad Karlovych Mikhelson

var full_name2 = user.get_fullname('Klara', 'Novikova'); // I am Klara Karlovych Novikova
    </pre></p>
    <p>В принципі, можна було б і так писати код, і ніхто б не скаржився. Але є один механізм, який може спростити нам життя. Цей механізм, як і багато інших, запозичений із живої мови, він дуже потужний, але, як це буває, ми настільки звикли до нього, що не помічаємо. Трошки віршів:</p>
    <p>У програмістів з великим стажем інколи розвиваються сильні професійні деформації, внаслідок яких, усі події свого життя вони спримають як сукупність об"єктів, у яких викликаються певні методи.</p>
    <p>Як бачите, коли ми викликаємо функцію як метод об"єкту, всередині функції сам цей об"єкт стає доступним через ключове слово this. Це дуже, дуже важливий момент, читайте попереднє речення і медитуйте над ним, поки до вас не прийде розуміння. Ось простіші приклади для засвоєння:</p>
    <p>У реальних буденних задачах веб-програмування вам навряд чи доведеться імітувати реальні процеси по типу поїдання бананів. В більшості випадків, за допомогю об"єктів будуть описані елементи веб-сторінки, а операції, які ви можете зробити з ними, будуть методами.</p>

    <h3>Ще раз про стандартні методи</h3>
    <p>Тепер ви можете свіжим оком подивитись на стандартні методи, які є, наприклад, у строчок.</p>
    <p><pre class="code__exemple">
      
      var str = 'ABCDEFG';
      var a = str.charAt(2); // 'C' !!!
    </pre></p>
    <p>Наприклад, метод .charAt(), який повертає символ по номеру. Тільки чому він повернув C, а не В, адже другий по порядку символ - це B? Справа в тому, що нумерація в джаваскрипті починається з нуля.</p>
    <p><pre class="code__exemple">
      
      a = str.charAt(0); // 'A'
    </pre></p>
    <p>Але головне питання не в цьому. str - це ж наче просто строчка, і аж ніяк не об"єкт, звідки у неї береться метод charAt? Відповідь: це такий хитрий трюк від розробників джаваскрипта, щоб полегшити ваше життя. Звичайно, str з усіх сил старається переконати вас: "Я строчка-строчка-строчка, я зовсім не об"єкт". І str таки дійсно не об"єкт, але деякі властивості об"єкта має. Це оці стандартні методи. Однак спроба присвоїти строчці якесь поле самотужки не увінчається успіхом.</p>
    <p>Отже, строчки і числа у джаваскрипті є звичайними строчками і числами, які інколи дозволяють себе вести з ними, як з об"єктами. Такий їхній лібералізм і доступність значно полегшує життя. Уявімо, якби усі стандартні методи були функціями.</p>
    <p><pre class="code__exemple">
      
// припустимо, ми маємо функцію charAt(), яка робить те саме, що і метод
var abyrvalg = 'abyrvalg';
var b = charAt(abyrvalg, 1); // 'b'
//і тут раптово!
var charAt = function(str, num){
  return 'ololo';
}

var y = charAt(abyrvalg, 2); // 'ololo' !!!
    </pre></p>
    <p>Як бачите, з функціями треба бути обреженим, т.як їхні імена не повинні збігатися з іменами інших функцій і змінних. Тому, дуже зручно, що більшість стандартних функцій працюють як методи. Не страшно їх перевизначити, і менше аргументів передавати!</p>

    <h3>Об"єкт як словник</h3>
    <p>Ще одне застосування джаваскриптових об"єктів, окрім моделювання реальних предметів - це функція "словника". Як працює словник? Ми шукаємо у ньому слово, а він повертає нам його значення. Так само можна використовувати і об"єкти! За домопогою них можна співставляти строчки. Припустимо, ми хочемо написати функцію, яка буде аналізувати українські автомобільні номери. На вхід ми будемо подавати номер, цільною строчкою, а на виході хочемо отримати об"єкт із його властивостями: область, номер і серія.</p>
    <p><pre class="code__exemple">
      
var plate = 'АН2755КК';
plate = parse_plate(plate); 
console.log(plate); // {region: 'Donetsk', number: '2755', suffix: 'KK'};
    </pre></p>
    <p>Для того, щоб написати таку функцію, нам знадобляться деякі строкові методи. Ми маємо строчку 'АН2755КК', з якої нам треба "вирізати" перші дві букви, потім цифри, а потім останні дві букви. Для цього є метод .slice(start, end), який повертає частину строчки між позиціями start і end.</p>
    <p><pre class="code__exemple">
      
var plate = 'АН2755КК';
var region = plate.slice(0, 2); // 'AH', символ під позицією end не включається
var number = plate.slice(2, 6); // 2755
    </pre></p>
    <p><pre class="code__exemple">
      
var region_names = {
  AA: 'Kyiv',
  AH: 'Donetsk',
  AP: 'Zaporizhzhya',
  ...
}
var region_code = 'AP';
var region = region_names[region_code]; // 'Zaporizhzhya'
    </pre></p>
    <p>region_names - це об"єкт, який виконує роль словника, він дозволяє, знаючи код області, отримати її назву. Так як ім"я ключа(код області) нам невідоме наперед, ми шукаємо потрібний елемент у об"єкті за допомогою нотації квадратних дужок. Давайте тепер спробуємо це склеїти у функцію</p>
    <p><pre class="code__exemple">

  var parse_plate = function(plate){
  var region_names = {
    AA: 'Kyiv',
    AH: 'Donetsk',
    AP: 'Zaporizhzhya',
    /* і т.д. */
  }
  var region_code = plate.slice(0, 2);
  var number = plate.slice(2, 6);
  var suffix = plate.slice(6);
    // якщо ми не ставимо другий аргумент, це означає - до кінця
  return {
    region: region_names[region_code],
    number: number,
    suffix: suffix
  }
}</pre></p>
    <p>Однак, необхідно продумати "захист від дурня"(це стандартна задача веб-програмування). Може таке бути, що людина введе номер, розділивши серію і номер пробілами! Тобто, не 'АН2755КК', а 'АН 2755 КК', і тоді наша логіка, зав"язана на позиціях літер, полетить к бісовій матері. Цю проблему можна вирішити, якщо превентивно видалити усі пробіли зі строчки! Ми поки що не вміємо видаляти усі пробіли зараз, тому зробимо це двічі.</p>
    <p><pre class="code__exemple">
      
  var parse_plate = function(plate){
  plate = plate.replace(" ", "");
  plate = plate.replace(" ", "");// прибираємо пробіли!
  var region_names = {
    AA: 'Kyiv',
    AH: 'Donetsk',
    AP: 'Zaporizhzhya',
    /* і т.д. */
  }
  var region_code = plate.slice(0, 2);
  var number = plate.slice(2, 6);
  var suffix = plate.slice(6);
  return {
    region: region_names[region_code],
    number: number,
    suffix: suffix
  }
}
    </pre></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
  </div>



  <script src="2__functions.js" type="text/javascript"></script>
  <script src="1__variables.js" type="text/javascript"></script>
  </div>
</body>
</html>